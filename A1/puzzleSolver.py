import sys
import heapq
from datetime import datetime
import time

# Different heuristics
HAMMING_DIST = 0
MANHATTAN_DIST = 1

# Different algorithms
A_STAR = 1
IDA = 2

# http://ai-maker.atrilla.net/the-recursive-best-first-search-algorithm/

# A puzzleSolver for solving the 8-puzzle and the 15-puzzle problem
class puzzleSolver(object):

    # the constructor of the class that initializes some of the basic data members such as goal state, actions, the
    # input matrix and the dimensions of the matrix, namely the row size and the column size.
    def __init__(self, board):
        # self.goal_state = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]]
        self.actions = ['U', 'D', 'R', 'L']
        self.moves = dict(U=[-1, 0], R=[0, 1],
                          D=[1, 0], L=[0, -1])

        self.input_matrix = board
        self.m = len(board)
        self.n = len(board[0])
        if self.n == 4:
            self.goal_state = [
                                [1, 2, 3, 4],
                                [5, 6, 7, 8],
                                [9, 10, 11, 12],
                                [13, 14, 15, 0]
                              ]
        elif self.n==3:
            self.goal_state = [
                                [1, 2, 3],
                                [4, 5, 6],
                                [7, 8, 0]
                              ]
        self.explored_nodes = []

    # Get valid moves function finds the gap in the input matrix, check if the particular position it is trying to move
    # on is valid and attempts to move the gap in the specific row and column number specified.

    # the functions are copied from the puzzleGenerator.py provided with the assignment specification
    def get_valid_moves(self, matrix):
        result = []
        x, y = -1, -1
        x, y = [[i, j] for i in range(self.m)
                        for j in range(self.n) if matrix[i][j] == 0][0]

        for action in self.actions:
            x2, y2 = x + self.moves[action][0], y + self.moves[action][1]
            next_move = None
            if (x2 >= 0) and (x2 < self.m) and (y2 >= 0) and (y2 < self.n):
                next_move = [row[:] for row in matrix]

                tmp = next_move[x][y]
                next_move[x][y] = next_move[x2][y2]
                next_move[x2][y2] = tmp

            if next_move is not None:
                result.append([next_move, action])

        return result

    # A heuristic function that takes in a matrix and then computes the number of misplaced tiles from the given state
    # to the goal state
    # Returns : the number of misplaced tiles and the matrix
    def heuristics_misplaced_tiles(self, matrix):
        misplaced_count = 0

        for i in range(self.m):
            for j in range(self.n):
                if self.goal_state[i][j] != matrix[i][j]:
                    misplaced_count += 1

        return [misplaced_count, matrix]

    # A heuristic function based on manhattan distance which basically computes the row and column distance of each of the
    # tiles from their final state
    # Returns : the manhattan distance (an integer) and the matrix
    def heuristics_manhattan_distance(self, matrix):
        # print matrix
        sum_mhd = 0
        for i in range(self.m):
            for j in range(self.n):
                if matrix[i][j] == 0:
                    continue
                row_distance = abs(i - int((matrix[i][j]-1) / self.m))
                col_distance = abs(j - ((matrix[i][j]-1) % self.n))
                sum_mhd += row_distance + col_distance
        return [sum_mhd, matrix]

    def reconstruct(self, state, camefrom):
        path = []
        while str(state) in camefrom.keys():
            current = camefrom[str(state)]
            state = current[0]
            path.append(current[1])
        return path[::-1]

    # this algorithm has been refered from the link : https://en.wikipedia.org/wiki/A*_search_algorithm

    # the crux of the problem solving algorithm
    # the function that returns the possible actions using the A* algorithm to start performing on the
    # start state to reach the goal state
    def a_star_solver(self, method):
        # a list to keep track of the list of explored nodes
        explored_states = set()
        camefrom = dict()
        # initialize the start as the given input matrix read from the file generated by the puzzleGenerator.py
        start = self.input_matrix

        # a list of all the nodes at the cusp of getting explored next
        frontier = []
        # a list to fetch the actual path to traverse from the start to reach the goal state
        final_path = []

        # logic to select which heuristic function to select to implement A* algorithm
        if method == HAMMING_DIST:
            h_fn = self.heuristics_misplaced_tiles
        elif method == MANHATTAN_DIST:
            h_fn = self.heuristics_manhattan_distance

        # compute the heuristic distance for the start state
        h, state = h_fn(start)
        node = dict(g=0, f=h, state=state, path='')
        frontier.append(node)

        # loop to go over the search space by checking the current length of the frontier list
        while len(frontier) > 0:
            # pop an element from the priority queue(heap) and get the element with the lowest heuristic distance value
            frontier.sort(key=lambda k: k['f'])
            current_node = frontier[0]

            # check if current_state is goal_state
            # you have found your node
            h, state = h_fn(current_node['state'])
            if h == 0:
                final_path = self.reconstruct(state, camefrom)
                return final_path, len(explored_states)

            frontier = frontier[1:]
            current_state = current_node['state']

            # if not explored yet, append the current state in the explored states list
            explored_states.add(str(current_state))

            # compute the heuristic distance for all the moves from the current state
            # and push all their heurisitic distance and the moved matrix for the next iteration and expand the
            # frontier one more level to the next level of the search space
            for move in self.get_valid_moves(current_state):
                if str(move[0]) in explored_states:
                    continue

                tentative_g = current_node['g'] + 1
                nodes = [x for x in frontier if x['state'] == move[0]]

                if len(nodes) == 0:
                    h, state = h_fn(move[0])
                    node = dict(g=tentative_g, f=tentative_g+h,
                                state=state, path=move[1])
                    frontier.append(node)
                    camefrom[str(state)] = (current_state, move[1])

                elif tentative_g > nodes[0]['g']:
                    continue

        # return the list of moves
        return final_path, -1



    # https://en.wikipedia.org/wiki/Iterative_deepening_A*
    # the helper function for the Iterative Deeping A* algorithm to compute the path from the start state to the goal state
    def _search(self, node, g, bound, h_fn, path, explored_nodes):
        # the heuristic value of the start state
        h_value, _ = h_fn(node)

        # the f-value for the start state
        f = g + h_value

        #if the f value is greater than the bound then return that value
        if f > bound:
            return f

        # if the node is equal to the goal state , then return that the goal state is found by the algorithm
        if node == self.goal_state:
            return -1

        # initialize the minimum value to infinity, to find the minimum value later
        minimum = float('inf')

        # compute the moves possible from the current state
        for move in self.get_valid_moves(node):
            # append the candidate state in the temporary path
            path.append(move[1])

            # increment the explored nodes count by 1
            explored_nodes[0] += 1
            #recursively call the function on the next state by incrementing the g value by 1
            t = self._search(move[0], g+1, bound, h_fn, path, explored_nodes)
            # if the goal state is found, then return found to the main function(or to the next thing in the recursion stack)

            if t == -1:
                # print('g value =', g)
                return -1
            else:
                # if not in the optimal path , then remove the candidate from the path
                path.pop()
            # find the minimum bound for the next iteration
            minimum = min(t, minimum)
        # return the minimum bound to the calling function
        return minimum


    # the function that returns the possible actions to perform using the IDA* algorithm to start performing on the
    # start state to reach the goal state
    def ida_star_solver(self, method):
        # logic to select which heuristic function to select to implement A* algorithm
        if method == HAMMING_DIST:
            h_fn = self.heuristics_misplaced_tiles
        elif method == MANHATTAN_DIST:
            h_fn = self.heuristics_manhattan_distance

        # the path to compute the ida* algorithm
        path = []
        #compute the initial bound and the start state
        bound, start = h_fn(self.input_matrix)


        explored_nodes = [1]

        while True:
            t = self._search(start, 0, bound, h_fn, path, explored_nodes)
            # if the final state is found, then return the path and the number of explored nodes to the calling function
            if t == -1:
                return path, explored_nodes
            # if the final state is not found, if the given limit of bounds, then return not found to the calling function
            elif t == float('inf'):
                return path, explored_nodes
            #set the new bound to be the new value of t received from the search function
            bound = t


# function that parses and reads the input matrix generated by puzzleGenerator.py
def read_input(f_name):
    m = []
    with open(f_name, 'r') as f:
        for line in f.readlines():
            line = line.strip('\n')
            row = [int('0'+x) for x in line.split(',')]
            m.append(row)
            print(row)
    return m


# function to write metrics
def write(f_name, path, num_explored, total_time, heuristic):
    if heuristic == MANHATTAN_DIST:
        title = 'Heuristic 1: Manhattan Distance'
    elif heuristic == HAMMING_DIST:
        title = 'Heuristic 2: Hamming Distance/No of misplaced tiles'
    else:
        title = 'Undefined heuristics'

    dirs = 'Directions: {}'.format(str(path))
    num_exp = 'Number of explored nodes: {}'.format(num_explored)
    sol_depth = 'The Solution Depth: {}'.format(len(path))
    time_taken = 'Time Taken: {0} microseconds, ' \
                 '{1} milliseconds'.format(total_time, total_time/1000)

    with open(f_name, 'a') as f:
        f.write('{0}\n{1}\n{2}\n{3}\n{4}\n\n'.format(title, dirs, num_exp,
                                                   sol_depth, time_taken))

# the main function to compute the paths using the A* and the IDA* algorithms
def main():
    # parsing of the command line arguments
    algo = IDA
    n = 3
    in_file = None
    out_file = None

    if len(sys.argv) == 5:
        algo = int(sys.argv[1])
        n = int(sys.argv[2])
        in_file = sys.argv[3]
        out_file = sys.argv[4]
    else:
        print('Usage: puzzleSolver.py')
        print('\t<Algo(1/2) - Algo to use: 1-A* 2-Memory Bounded>')
        print('\t<N - puzzle-format : 3= 8-puzzle 4=15-puzzle>')
        print('\t<INPATH - input file path>')
        print('\t<OUTPATH - output file path>')
        print('Usage: puzzleGenerator.py')
        print('\t<N> <OUTPATH>')
        return

    if algo != A_STAR and algo != IDA:
        print('the value of Algo must be either 1/2.')
        print('1 for A* and 2 for Memory Bound Search')
        return

    if n != 3 and n != 4:
        print ("the value of n must be either 3/4.")
        print("3 for 8-puzzle and 4 for 15-puzzle")
        return

    if in_file is None or in_file == '':
        print ("the infile cannot be empty")
        return

    if out_file is None or out_file == '':
        print ("the outfile cannot be empty")
        return

    # in_file = "input_01.txt"
    # out_file = "test_01.txt"
    matrix = read_input(in_file)
    with open(out_file, 'w') as f:
            pass

    #take the path corresponding the required algorithm
    if algo == A_STAR:
        #create an instance of the puzzleSolver class
        s = puzzleSolver(matrix)

        # compute the paths using both the possible heuristic
        for h in [MANHATTAN_DIST, HAMMING_DIST]:
            # get the current value of system time
            start_time = datetime.now()
            #call the function to compute the path using A*
            path, num_explored = s.a_star_solver(h)
            # get the current value of system time
            end_time = datetime.now()
            #take the difference to get the time taken by the function to calculate the path in microseconds
            total_time = (end_time - start_time).microseconds
            # write the details in the output file
            write(out_file, path, num_explored, total_time, h)

    elif algo == IDA:
        #create an instance of the puzzleSolver class
        s = puzzleSolver(matrix)

        for h in [MANHATTAN_DIST, HAMMING_DIST]:
            # get the current value of system time
            start_time = datetime.now()
            #call the function to compute the path using IDA*
            path, num_explored = s.ida_star_solver(h)
            # get the current value of the system time
            end_time = datetime.now()
            #take the difference to get the time taken by the function to calculate the path in microseconds
            total_time = (end_time - start_time).microseconds
            # write the details in the output file
            write(out_file, path, num_explored[0], total_time, h)


if __name__ == '__main__':
    main()
