import sys
import heapq
from datetime import datetime
import time

# Different heuristics
HAMMING_DIST = 0
MANHATTAN_DIST = 1

# Different algorithms
A_STAR = 1
RBFS = 2

# http://ai-maker.atrilla.net/the-recursive-best-first-search-algorithm/

# A puzzleSolver for solving the 8-puzzle and the 15-puzzle problem
class puzzleSolver(object):

    # the constructor of the class that initializes some of the basic data members such as goal state, actions, the
    # input matrix and the dimensions of the matrix, namely the row size and the column size.
    def __init__(self, board):
        # self.goal_state = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]]
        self.actions = ['U', 'D', 'R', 'L']
        self.moves = dict(U=[-1, 0], R=[0, 1],
                          D=[1, 0], L=[0, -1])

        self.input_matrix = board
        self.m = len(board)
        self.n = len(board[0])
        if self.n == 4:
            self.goal_state = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]]
        elif self.n==3:
            self.goal_state = [[1, 2, 3], [4,5, 6], [7, 8, 0]]

    # Get valid moves function finds the gap in the input matrix, check if the particular position it is trying to move
    # on is valid and attempts to move the gap in the specific row and column number specified.

    # the functions are copied from the puzzleGenerator.py provided with the assignment specification
    def get_valid_moves(self, matrix):
        result = []
        x, y = -1, -1
        x, y = [[i, j] for i in range(self.m)
                        for j in range(self.n) if matrix[i][j] == 0][0]

        for action in self.actions:
            x2, y2 = x + self.moves[action][0], y + self.moves[action][1]
            next_move = None
            if (x2 >= 0) and (x2 < self.m) and (y2 >= 0) and (y2 < self.n):
                next_move = [row[:] for row in matrix]

                tmp = next_move[x][y]
                next_move[x][y] = next_move[x2][y2]
                next_move[x2][y2] = tmp

            if next_move is not None:
                result.append([next_move, action])

        return result

    # A heuristic function that takes in a matrix and then computes the number of misplaced tiles from the given state
    # to the goal state
    # Returns : the number of misplaced tiles and the matrix
    def heuristics_misplaced_tiles(self, matrix):
        misplaced_count = 0

        for i in range(self.m):
            for j in range(self.n):
                if self.goal_state[i][j] != matrix[i][j]:
                    misplaced_count += 1

        return [misplaced_count, matrix]

    # A heuristic function based on manhattan distance which basically computes the row and column distance of each of the
    # tiles from their final state
    # Returns : the manhattan distance (an integer) and the matrix
    def heuristics_manhattan_distance(self, matrix):
        sum_mhd = 0
        for i in range(self.m):
            for j in range(self.n):
                if matrix[i][j] == 0:
                    continue
                row_distance = abs(i - int((matrix[i][j]-1) / self.m))
                col_distance = abs(j - ((matrix[i][j]-1) % self.n))
                sum_mhd += row_distance + col_distance
        return [sum_mhd, matrix]

    # the crux of the problem solving algorithm
    # the function that returns the possible actions to start performing on the start state to reach the goal state
    def solver(self, method=0):
        # a list to keep track of the list of explored nodes
        explored_states = []
        solution_depth = 0

        # initialize the start as the given input matrix read from the file generated by the puzzleGenerator.py
        start = self.input_matrix

        # a list of all the nodes at the cusp of getting explored next
        frontier = []
        # a list to fetch the actual path to traverse from the start to reach the goal state
        backtrack = []

        # logic to select which heuristic function to select to implement A* algorithm
        if method == HAMMING_DIST:
            h_fn = self.heuristics_misplaced_tiles
        elif method == MANHATTAN_DIST:
            h_fn = self.heuristics_manhattan_distance

        # compute the heuristic distance for the start state
        hnode = h_fn(start)
        hnode.append('')

        # using a heap to implement the priority queue and pushing the node in the frontier
        heapq.heappush(frontier, hnode)

        # loop to go over the search space by checking the current length of the frontier list
        while len(frontier) > 0:
            # pop an element from the priority queue(heap) and get the element with the lowest heuristic distance value
            (h, current_state, path) = heapq.heappop(frontier)

            # if the path is not empty , append the path to the resultant path
            if path != '':
                backtrack.append(path)
                solution_depth += 1

            # check to see if the current state is already explored, if it is, do not explore it again and continue for
            # the next iteration
            if current_state in explored_states:
                continue

            # if not explored yet, append the current state in the explored states list
            explored_states.append(current_state)

            # check if current_state is goal_state
            # you have found your node
            if h == 0:
                break

            # compute the heuristic distance for all the moves from the current state
            # and push all their heurisitic distance and the moved matrix for the next iteration and expand the
            # frontier one more level to the next level of the search space
            for move in self.get_valid_moves(current_state):
                hnode = h_fn(move[0])
                hnode.append(move[1])
                heapq.heappush(frontier, hnode)

        # return the list of moves
        return backtrack, solution_depth

# function that parses and reads the input matrix generated by puzzleGenerator.py
def read_input(f_name):
    m = []
    with open(f_name, 'r') as f:
        for line in f.readlines():
            line = line.strip('\n')
            row = [int('0'+x) for x in line.split(',')]
            m.append(row)
            print(row)
    return m

# function to write metrics
def write(f_name, path, depth, total_time, heuristic):
    print('write', heuristic)
    if heuristic == HAMMING_DIST:
        title = 'Heuristic 1: Manhattan Distance'
    elif heuristic == MANHATTAN_DIST:
        title = 'Heuristic 2: Hamming Distance/No of misplaced tiles'
    else:
        title = 'Undefined heuristics'

    dirs = 'Directions: {}'.format(str(path))
    num_exp = 'Number of explored nodes: {}'.format(len(path))
    sol_depth = 'The Solution Depth: {}'.format(depth)
    time_taken = 'Time Taken: {0} microseconds, {1} milliseconds'.format(total_time, total_time/1000)

    with open(f_name, 'a') as f:
        f.write('{0}\n{1}\n{2}\n{3}\n{4}\n\n'.format(title, dirs, num_exp,
                                                   sol_depth, time_taken))

if __name__ == '__main__':
    algo = A_STAR
    n = 3
    in_file = None
    out_file = None

    if len(sys.argv) == 5:
        algo = int(sys.argv[1])
        n = int(sys.argv[2])
        in_file = sys.argv[3]
        out_file = sys.argv[4]
    else:
        print('Wrong number of arguments.')
        print('Usage:')
        print('puzzleSolver.py <Algo(1/2) - '\
              'Algo to use: 1-A* 2-Memory Bounded> '\
              '<N - puzzle-format : 3= 8-puzzle 4=15-puzzle> '\
              '<INPATH - input file path> '\
              '<OUTPATH - output file path>')
        print('puzzleGenerator.py <N> <OUTPATH>')

    if algo != A_STAR and algo != RBFS:
        print ("the value of Algo must be either 1/2. 1 for A* and 2 for Memory Bound Search(RBFS)")

    if n != 3 and n != 4:
        print ("the value of n must be either 3/4. 3 for 8-puzzle and 4 for 15-puzzle")

    if in_file is None:
        print ("the infile cannot be empty")

    if out_file is None:
        print ("the outfile cannot be empty")

    matrix = read_input(in_file)

    if algo == A_STAR:
        s = puzzleSolver(matrix)

        with open(out_file, 'w') as f:
            pass

        for h in [MANHATTAN_DIST, HAMMING_DIST]:
            start_time = datetime.now()
            path, depth = s.solver(h)
            end_time = datetime.now()
            total_time = (end_time - start_time).microseconds
            write(out_file, path, depth, total_time, h)

    elif algo == RBFS:
        print('RBFS coming sooon!!!')

