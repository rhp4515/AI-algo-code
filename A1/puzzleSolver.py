import sys
import heapq

# http://ai-maker.atrilla.net/the-recursive-best-first-search-algorithm/

# A puzzleSolver for solving the 8-puzzle and the 15-puzzle problem
class puzzleSolver(object):

    # the constructor of the class that initializes some of the basic data members such as goal state, actions, the
    # input matrix and the dimensions of the matrix, namely the row size and the column size.
    def __init__(self, board):
        # self.goal_state = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]]
        self.actions = ['up', 'down', 'right', 'left']
        self.moves = dict(up=[-1, 0], right=[0, 1],
                          down=[1, 0], left=[0, -1])

        self.input_matrix = board
        self.m = len(board)
        self.n = len(board[0])
        if self.n == 4:
            self.goal_state = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]]
        elif self.n==3:
            self.goal_state = [[1, 2, 3], [4,5, 6], [7, 8, 0]]

    # Get valid moves function finds the gap in the input matrix, check if the particular position it is trying to move
    # on is valid and attempts to move the gap in the specific row and column number specified.

    # the functions are copied from the puzzleGenerator.py provided with the assignment specification
    def get_valid_moves(self, matrix):
        result = []
        x, y = -1, -1
        x, y = [[i, j] for i in range(self.m)
                        for j in range(self.n) if matrix[i][j] == 0][0]

        for action in self.actions:
            x2, y2 = x + self.moves[action][0], y + self.moves[action][1]
            next_move = None
            if (x2 >= 0) and (x2 < self.m) and (y2 >= 0) and (y2 < self.n):
                next_move = [row[:] for row in matrix]

                tmp = next_move[x][y]
                next_move[x][y] = next_move[x2][y2]
                next_move[x2][y2] = tmp

            if next_move is not None:
                result.append([next_move, action])

        return result

    # A heuristic function that takes in a matrix and then computes the number of misplaced tiles from the given state
    # to the goal state 
    # Returns : the number of misplaced tiles and the matrix
    def heuristics_misplaced_tiles(self, matrix):
        misplaced_count = 0

        for i in range(self.m):
            for j in range(self.n):
                if self.goal_state[i][j] != matrix[i][j]:
                    misplaced_count += 1

        return [misplaced_count, matrix]

    # A heuristic function based on manhattan distance which basically computes the row and column distance of each of the 
    # tiles from their final state
    # Returns : the manhattan distance (an integer) and the matrix
    def heuristics_manhattan_distance(self, matrix):
        sum_mhd = 0
        for i in range(self.m):
            for j in range(self.n):
                if matrix[i][j] == 0:
                    continue
                row_distance = abs(i - int((matrix[i][j]-1) / self.m))
                col_distance = abs(j - ((matrix[i][j]-1) % self.n))
                sum_mhd += row_distance + col_distance
        return [sum_mhd, matrix]

    # the crux of the problem solving algorithm 
    # the function that returns the possible actions to start performing on the start state to reach the goal state
    def solver(self, method=0):
        # a list to keep track of the list of explored nodes
        explored_states = []
        solution_depth = 0

        # initialize the start as the given input matrix read from the file generated by the puzzleGenerator.py
        start = self.input_matrix

        # a list of all the nodes at the cusp of getting explored next
        frontier = []
        # a list to fetch the actual path to traverse from the start to reach the goal state
        backtrack = []

        # logic to select which heuristic function to select to implement A* algorithm
        if method == 0:
            h_fn = self.heuristics_misplaced_tiles
        elif method == 1:
            h_fn = self.heuristics_manhattan_distance

        # compute the heuristic distance for the start state
        hnode = h_fn(start)
        hnode.append('')
        
        # using a heap to implement the priority queue and pushing the node in the frontier 
        heapq.heappush(frontier, hnode)

        # loop to go over the search space by checking the current length of the frontier list
        while len(frontier) > 0:
            # pop an element from the priority queue(heap) and get the element with the lowest heuristic distance value
            (h, current_state, path) = heapq.heappop(frontier)

            # if the path is not empty , append the path to the resultant path
            if path != '':
                backtrack.append(path)
                solution_depth += 1

            # check to see if the current state is already explored, if it is, do not explore it again and continue for
            # the next iteration
            if current_state in explored_states:
                continue

            # if not explored yet, append the current state in the explored states list
            explored_states.append(current_state)

            # check if current_state is goal_state
            # you have found your node
            if h == 0:
                break

            # compute the heuristic distance for all the moves from the current state
            # and push all their heurisitic distance and the moved matrix for the next iteration and expand the 
            # frontier one more level to the next level of the search space 
            for move in self.get_valid_moves(current_state):
                hnode = h_fn(move[0])
                hnode.append(move[1])
                heapq.heappush(frontier, hnode)

        # return the list of moves 
        return backtrack, solution_depth

# function that parses and reads the input matrix generated by puzzleGenerator.py
def read_input(f_name):
    m = []
    with open(f_name, 'r') as f:
        for line in f.readlines():
            line = line.strip('\n')
            row = [int('0'+x) for x in line.split(',')]
            m.append(row)
            print(row)
    return m

def file_write(target,path,total_time,heuristic):

    if heuristic == 1:
        target.write('Heuristic 1: Manhattan Distance')
        target.write('\n')
    else:
        target.write('Heuristic 1: Hamming Distance/No of misplaced tiles')
        target.write('\n')
    target.write('Directions:')
    target.write(str(path[0]))
    target.write('\n')
    target.write('Number of explored nodes:')
    target.write(str(len(path[0])))
    target.write('\n')
    target.write('The Solution Depth:')
    target.write(str(path[1]))
    target.write('\n')
    target.write('Time Taken:')
    target.write(str(total_time))
    target.write(' microseconds , ')
    target.write(str(total_time/1000))
    target.write(' milliseconds')
    target.write('\n')

if __name__ == '__main__':
    algo = 1
    n = 3
    in_file = ''
    out_file = ''

    if len(sys.argv) == 5:
        algo = int(sys.argv[1])
        n = int(sys.argv[2])
        in_file = sys.argv[3]
        out_file = sys.argv[4]
    else:
        print('Wrong number of arguments. Usage:\npuzzleSolver.py <Algo(1/2) - Algo to use : 1-A* 2-Memory Bounded> <N - puzzle-format : 3= 8-puzzle 4=15-puzzle> <INPATH - input file path> <OUTPATH - output file path>\npuzzleGenerator.py <N> <OUTPATH>')

    if algo != 1 and algo != 2:
        print ("the value of Algo must be either 1/2. 1 for A* and 2 for Memory Bound Search(RBFS)")


    if n != 3 and n != 4:
        print ("the value of n must be either 3/4. 3 for 8-puzzle and 4 for 15-puzzle")


    if in_file == '':
        print ("the infile cannot be empty")


    if out_file == '':
        print ("the infile cannot be empty")

    filename = in_file
    matrix = read_input(filename)
    s = puzzleSolver(matrix)
    target = open(out_file, 'w+')

    start_time = datetime.datetime.now()
    path = s.solver(1)
    end_time = datetime.datetime.now()
    total_time = (end_time - start_time).microseconds


    file_write(target,path,total_time,1)

    start_time = datetime.datetime.now()
    path = s.solver(0)
    end_time = datetime.datetime.now()
    total_time = (end_time - start_time).microseconds

    file_write(target,path,total_time,0)