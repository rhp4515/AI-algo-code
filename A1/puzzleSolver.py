import sys
import heapq
from datetime import datetime
import time

# Different heuristics
HAMMING_DIST = 0
MANHATTAN_DIST = 1

# Different algorithms
A_STAR = 1
RBFS = 2

# http://ai-maker.atrilla.net/the-recursive-best-first-search-algorithm/

# A puzzleSolver for solving the 8-puzzle and the 15-puzzle problem
class puzzleSolver(object):

    # the constructor of the class that initializes some of the basic data members such as goal state, actions, the
    # input matrix and the dimensions of the matrix, namely the row size and the column size.
    def __init__(self, board):
        # self.goal_state = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 0]]
        self.actions = ['U', 'D', 'R', 'L']
        self.moves = dict(U=[-1, 0], R=[0, 1],
                          D=[1, 0], L=[0, -1])

        self.input_matrix = board
        self.m = len(board)
        self.n = len(board[0])
        if self.n == 4:
            self.goal_state = [
                                [1, 2, 3, 4],
                                [5, 6, 7, 8],
                                [9, 10, 11, 12],
                                [13, 14, 15, 0]
                              ]
        elif self.n==3:
            self.goal_state = [
                                [1, 2, 3],
                                [4, 5, 6],
                                [7, 8, 0]
                              ]
        self.explored_nodes = []

    # Get valid moves function finds the gap in the input matrix, check if the particular position it is trying to move
    # on is valid and attempts to move the gap in the specific row and column number specified.

    # the functions are copied from the puzzleGenerator.py provided with the assignment specification
    def get_valid_moves(self, matrix):
        result = []
        x, y = -1, -1
        x, y = [[i, j] for i in range(self.m)
                        for j in range(self.n) if matrix[i][j] == 0][0]

        for action in self.actions:
            x2, y2 = x + self.moves[action][0], y + self.moves[action][1]
            next_move = None
            if (x2 >= 0) and (x2 < self.m) and (y2 >= 0) and (y2 < self.n):
                next_move = [row[:] for row in matrix]

                tmp = next_move[x][y]
                next_move[x][y] = next_move[x2][y2]
                next_move[x2][y2] = tmp

            if next_move is not None:
                result.append([next_move, action])

        return result

    # A heuristic function that takes in a matrix and then computes the number of misplaced tiles from the given state
    # to the goal state
    # Returns : the number of misplaced tiles and the matrix
    def heuristics_misplaced_tiles(self, matrix):
        misplaced_count = 0

        for i in range(self.m):
            for j in range(self.n):
                if self.goal_state[i][j] != matrix[i][j]:
                    misplaced_count += 1

        return [misplaced_count, matrix]

    # A heuristic function based on manhattan distance which basically computes the row and column distance of each of the
    # tiles from their final state
    # Returns : the manhattan distance (an integer) and the matrix
    def heuristics_manhattan_distance(self, matrix):
        # print matrix
        sum_mhd = 0
        for i in range(self.m):
            for j in range(self.n):
                if matrix[i][j] == 0:
                    continue
                row_distance = abs(i - int((matrix[i][j]-1) / self.m))
                col_distance = abs(j - ((matrix[i][j]-1) % self.n))
                sum_mhd += row_distance + col_distance
        return [sum_mhd, matrix]

    # the crux of the problem solving algorithm
    # the function that returns the possible actions to start performing on the
    # start state to reach the goal state
    def a_star_solver(self, method):
        # a list to keep track of the list of explored nodes
        explored_states = set()
        solution_depth = 0

        # initialize the start as the given input matrix read from the file generated by the puzzleGenerator.py
        start = self.input_matrix

        # a list of all the nodes at the cusp of getting explored next
        frontier = []
        # a list to fetch the actual path to traverse from the start to reach the goal state
        backtrack = []

        # logic to select which heuristic function to select to implement A* algorithm
        if method == HAMMING_DIST:
            h_fn = self.heuristics_misplaced_tiles
        elif method == MANHATTAN_DIST:
            h_fn = self.heuristics_manhattan_distance

        # compute the heuristic distance for the start state
        hnode = h_fn(start)
        # hnode.append(0)
        hnode.append('')

        # using a heap to implement the priority queue and pushing the node in the frontier
        heapq.heappush(frontier, hnode)

        # loop to go over the search space by checking the current length of the frontier list
        while len(frontier) > 0:
            # pop an element from the priority queue(heap) and get the element with the lowest heuristic distance value
            (f, current_state, path) = heapq.heappop(frontier)

            h, _ = h_fn(current_state)
            # check if current_state is goal_state
            # you have found your node
            if h == 0:
                break

            # if not explored yet, append the current state in the explored states list
            explored_states.add(str(current_state))

            # if the path is not empty , append the path to the resultant path
            if path != '':
                backtrack.append(path)
                solution_depth += 1

            # compute the heuristic distance for all the moves from the current state
            # and push all their heurisitic distance and the moved matrix for the next iteration and expand the
            # frontier one more level to the next level of the search space
            for move in self.get_valid_moves(current_state):
                if str(move[0]) in explored_states:
                    continue

                if move[0] not in frontier:
                    hnode = h_fn(move[0])
                    hnode.append(move[1])
                    hnode[0] += 1
                    heapq.heappush(frontier, hnode)


        # return the list of moves
        return backtrack, solution_depth

    def _rbfs_solver(self, parent, h_fn, limit):
        print('parent', parent['h'], parent['state'])
        if parent['state'] == self.goal_state:
            return [parent['path']], 0

        # if parent['state'] not in self.explored_nodes:
        #     self.explored_nodes.append(parent['state'])

        moves = self.get_valid_moves(parent['state'])

        moves = [x for x in moves]

        if len(moves) == 0:
            return None, float('inf')

        children_nodes = []

        for move in moves:
            h, state = h_fn(move[0])
            print(h, state, parent['state'])
            hnode = dict(state=state, h=h+1, path=move[1])
            children_nodes.append(hnode)

        while True:
            children_nodes.sort(key=lambda k: k['h'])

            best_child = children_nodes[0]
            print('best_child', best_child)

            if best_child['h'] > limit:
                return None, limit

            if len(children_nodes) > 1:
                next_best_h = children_nodes[1]['h']
            else:
                return float('inf')

            result, best_child['h'] = self._rbfs_solver(best_child, h_fn, min(limit, next_best_h))

            if result is not None:
                if parent['path'] != '':
                    result.insert(0, parent['path'])
                return result, best_child['h']


    def rbfs_solver(self, method):
        start = self.input_matrix

        if method == HAMMING_DIST:
            h_fn = self.heuristics_misplaced_tiles
        elif method == MANHATTAN_DIST:
            h_fn = self.heuristics_manhattan_distance

        h, _ = h_fn(start)
        hnode = dict(state=start, h=h, path='')

        return self._rbfs_solver(hnode, h_fn, float('inf'))

    def _search(self, node, g, bound, h_fn, path):
        h_value, _ = h_fn(node)
        f = g + h_value

        if f > bound:
            return f

        if node == self.goal_state:
            return -1

        minimum = float('inf')

        for move in self.get_valid_moves(node):
            path.append(move[1])
            t = self._search(move[0], g+1, bound, h_fn, path)
            if t == -1:
                return -1
            else:
                path.pop()
            minimum = min(t, minimum)
        return minimum

    def ida_star_solver(self, method):
        h_fn = self.heuristics_manhattan_distance
        path = []
        bound, start = h_fn(self.input_matrix)

        while True:
            t = self._search(start, 0, bound, h_fn, path)
            if t == -1:
                return bound, path
            elif t == float('inf'):
                return -2 , path
            bound = t


# function that parses and reads the input matrix generated by puzzleGenerator.py
def read_input(f_name):
    m = []
    with open(f_name, 'r') as f:
        for line in f.readlines():
            line = line.strip('\n')
            row = [int('0'+x) for x in line.split(',')]
            m.append(row)
            print(row)
    return m

# function to write metrics
def write(f_name, path, depth, total_time, heuristic):
    if heuristic == MANHATTAN_DIST:
        title = 'Heuristic 1: Manhattan Distance'
    elif heuristic == HAMMING_DIST:
        title = 'Heuristic 2: Hamming Distance/No of misplaced tiles'
    else:
        title = 'Undefined heuristics'

    dirs = 'Directions: {}'.format(str(path))
    num_exp = ""
    # num_exp = 'Number of explored nodes: {}'.format(len(path))
    sol_depth = 'The Solution Depth: {}'.format(depth)
    time_taken = 'Time Taken: {0} microseconds, ' \
                 '{1} milliseconds'.format(total_time, total_time/1000)

    with open(f_name, 'a') as f:
        f.write('{0}\n{1}\n{2}\n{3}\n{4}\n\n'.format(title, dirs, num_exp,
                                                   sol_depth, time_taken))

def main():
    algo = RBFS
    n = 3
    in_file = None
    out_file = None

    if len(sys.argv) == 5:
        algo = int(sys.argv[1])
        n = int(sys.argv[2])
        in_file = sys.argv[3]
        out_file = sys.argv[4]
    else:
        print('Usage: puzzleSolver.py')
        print('\t<Algo(1/2) - Algo to use: 1-A* 2-Memory Bounded>')
        print('\t<N - puzzle-format : 3= 8-puzzle 4=15-puzzle>')
        print('\t<INPATH - input file path>')
        print('\t<OUTPATH - output file path>')
        print('Usage: puzzleGenerator.py')
        print('\t<N> <OUTPATH>')
        return

    if algo != A_STAR and algo != RBFS:
        print('the value of Algo must be either 1/2.')
        print('1 for A* and 2 for Memory Bound Search')
        return

    if n != 3 and n != 4:
        print ("the value of n must be either 3/4.")
        print("3 for 8-puzzle and 4 for 15-puzzle")
        return

    if in_file is None or in_file == '':
        print ("the infile cannot be empty")
        return

    if out_file is None or out_file == '':
        print ("the outfile cannot be empty")
        return

    # in_file = "input_01.txt"
    # out_file = "test_01.txt"
    matrix = read_input(in_file)
    with open(out_file, 'w') as f:
            pass

    if algo == A_STAR:
        s = puzzleSolver(matrix)

        for h in [MANHATTAN_DIST, HAMMING_DIST]:
            start_time = datetime.now()
            path, depth = s.a_star_solver(h)
            end_time = datetime.now()
            total_time = (end_time - start_time).microseconds
            write(out_file, path, depth, total_time, h)

    elif algo == RBFS:
        s = puzzleSolver(matrix)

        for h in [MANHATTAN_DIST, HAMMING_DIST]:
            start_time = datetime.now()
            path = s.ida_star_solver(h)
            # print "the value received from ida star is"
            # print path
            end_time = datetime.now()
            total_time = (end_time - start_time).microseconds
            write(out_file, path[1], len(path[1]), total_time, h)


if __name__ == '__main__':
    main()
